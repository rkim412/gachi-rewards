// Script to reset migrations for PostgreSQL
import { readFileSync, writeFileSync, existsSync, rmSync, mkdirSync, readdirSync } from 'fs';
import { join } from 'path';
import { execSync } from 'child_process';

// Load .env file manually (dotenv might not be installed)
const envPath = join(process.cwd(), '.env');
if (existsSync(envPath)) {
  const envContent = readFileSync(envPath, 'utf8');
  envContent.split('\n').forEach(line => {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith('#') && trimmed.includes('=')) {
      const [key, ...valueParts] = trimmed.split('=');
      const value = valueParts.join('=').trim();
      // Remove quotes if present
      const cleanValue = value.replace(/^["']|["']$/g, '');
      if (key && cleanValue) {
        process.env[key.trim()] = cleanValue;
      }
    }
  });
}

console.log('üîÑ Resetting migrations for PostgreSQL...\n');

const migrationsDir = join(process.cwd(), 'prisma', 'migrations');
const lockFile = join(migrationsDir, 'migration_lock.toml');

try {
  // Step 1: Backup old migrations (optional - we'll just remove them)
  console.log('üì¶ Removing old SQLite migrations...');
  
  if (existsSync(migrationsDir)) {
    // List all migration folders
    const files = readdirSync(migrationsDir, { withFileTypes: true });
    const migrationDirs = files
      .filter(file => file.isDirectory() && /^\d+_/.test(file.name))
      .map(file => file.name);
    
    if (migrationDirs.length > 0) {
      console.log(`   Found ${migrationDirs.length} old migration(s):`);
      migrationDirs.forEach(dir => console.log(`   - ${dir}`));
      console.log('   (These are SQLite-specific and will be replaced)\n');
    }
    
    // Remove all migration directories except migration_lock.toml
    migrationDirs.forEach(dir => {
      const dirPath = join(migrationsDir, dir);
      rmSync(dirPath, { recursive: true, force: true });
      console.log(`   ‚úÖ Removed ${dir}`);
    });
  }

  // Step 2: Ensure migration_lock.toml is set to postgresql
  console.log('\nüìù Ensuring migration_lock.toml is set to postgresql...');
  writeFileSync(lockFile, `# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
`, 'utf8');
  console.log('   ‚úÖ migration_lock.toml updated\n');

  // Step 3: Verify DATABASE_URL
  if (!process.env.DATABASE_URL) {
    console.error('‚ùå DATABASE_URL environment variable is not set!');
    console.error('   Run: npm run db:fix-env');
    process.exit(1);
  }

  if (!process.env.DATABASE_URL.startsWith('postgresql://') && !process.env.DATABASE_URL.startsWith('postgres://')) {
    console.error('‚ùå DATABASE_URL must start with postgresql:// or postgres://');
    process.exit(1);
  }

  console.log('‚úÖ DATABASE_URL is set correctly\n');

  // Step 4: Create fresh migration
  console.log('üöÄ Creating fresh PostgreSQL migration...\n');
  
  try {
    execSync('npx prisma migrate dev --name init_postgresql', {
      stdio: 'inherit',
      env: process.env,
      cwd: process.cwd()
    });
    
    console.log('\n‚úÖ Successfully created PostgreSQL migrations!');
    console.log('\nüìã Next steps:');
    console.log('   1. Verify tables were created: npm run db:test');
    console.log('   2. Check Neon dashboard to see your tables');
    
  } catch (error) {
    console.error('\n‚ùå Error creating migration');
    console.error('   Make sure DATABASE_URL is set correctly in .env');
    console.error('   Run: npm run db:fix-env');
    process.exit(1);
  }

} catch (error) {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
}
